<!DOCTYPE html>

<!--
Lightweight browser based viewer for 360 degree images and videos.
Created by Ben Egan: https://github.com/ProGamerGov


Controls

| Action             | How to Use                                 |
| ------------------ | -------------------------------------------|
| Navigate View      | Left-click + drag or touch + drag          |
| Zoom               | Mouse wheel or pinch gesture               |
| Fullscreen         | Browser fullscreen and VR headset control  |
| Stereo Toggle      | Bottom-left "Stereo" button                |
| Screenshot         | Camera icon at bottom center               |
| Upload/Reset Media | "Upload" button below controls             |
| Play/Pause Video   | Play/pause button on video controls        |
| Seek in Video      | Use the timeline slider                    |

Additonal info
- Stereo Toggle: Switch between monoscopic and stereo images (mono/top-bottom/side-by-side)
- Upload/Reset Media: New media can be uploaded via drag and drop at any time.


Loading from external URLs
- Images and videos can be loaded from other websites by appending '?url=' or '?src=' to the viewer URL, followed by the direct media link.
- Example: https://progamergov.github.io/html-360-viewer?url=https://example.com/example_image.jpg
- This only works when the viewer is hosted via a local or remote web server (not directly opened as a file).
- See here for more details: https://aframe.io/docs/1.7.0/introduction/installation.html#use-a-local-server
- You can also provide the mono/stereo viewing mode that should be used when loading the image.
- To specify the viewing mode to use, append '&stereo=0' for monoscopic (default), '&stereo=1' for up/down stereo, and '&stereo=2' for right/left stereo.
- Example: https://progamergov.github.io/html-360-viewer?url=https://example.com/example_image.jpg&stereo=0


BibTeX
@misc{egan2025html360viewer,
  title={Browser-Based Viewer for 360 Images and Videos},
  author={Egan, Ben},
  year={2025},
  publisher={GitHub},
  howpublished={\url{https://github.com/ProGamerGov/html-360-viewer}}
}

MIT License
Copyright (c) 2025 Ben Egan
-->

<html lang="en">
<head>
    <!-- Primary Meta Tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="title" content="Browser-Based Viewer for 360¬∞ Images and Videos">
    <meta name="description" content="A lightweight, browser-based viewer for interactive 360¬∞ panoramas and videos. Supports monoscopic and stereo formats, zoom, and screenshot.">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://progamergov.github.io/html-360-viewer">
    <meta property="og:title" content="Browser-Based Viewer for 360¬∞ Images and Videos">
    <meta property="og:description" content="A lightweight, browser-based viewer for interactive 360¬∞ panoramas and videos. Supports monoscopic and stereo formats, zoom, and screenshot.">
    <meta property="og:image" content="https://raw.githubusercontent.com/ProGamerGov/html-360-viewer/main/examples/example_image.png">

    <!-- Page Title -->
    <title>360¬∞ Panorama & Video Viewer</title>

    <!-- A-Frame (offline): place `aframe.min.js` next to this HTML -->
    <script src="aframe.min.js"></script>

    <!-- three.js (offline): place `three.min.js` next to this HTML -->
    <script src="three.min.js"></script>

    <style>
        /* --- Layout & Typography --- */
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: pan-x pan-y; /* disable pinch-zoom */
        }
        #container {
            width: 100%;
            height: 100vh;
            position: relative;
            background: #000;
        }

        /* --- Drop area --- */
        #dropArea {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #f5f5f5;
            border: 3px dashed #ccc;
            z-index: 10;
            transition: 0.2s ease all;
        }
        #dropArea.hidden { display: none; }
        #dropArea h2 { margin-bottom: 12px; color: #333; }
        #fileInput { display: none; }
        #selectButton {
            padding: 12px 24px;
            background: #4285f4;
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
        }
        #selectButton:hover { background: #3367d6; }

        /* --- A-Frame container --- */
        #aframeContainer {
            position: absolute;
            inset: 0;
        }

        /* --- three.js container (Little Planet) --- */
        #threeContainer {
            position: absolute;
            inset: 0;
            display: none;
            z-index: 5;
        }
        #threeContainer canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* --- Little Planet right panel --- */
        #littlePlanetPanel {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 360px;
            max-width: min(360px, 92vw);
            background: rgba(20, 20, 20, 0.92);
            border-left: 1px solid rgba(255,255,255,0.12);
            z-index: 60;
            display: none;
            padding: 14px 14px 18px;
            overflow: auto;
            color: rgba(255,255,255,0.92);
            backdrop-filter: blur(3px);
        }
        #littlePlanetPanel h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            letter-spacing: 0.2px;
        }
        .lp-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .lp-row label {
            min-width: 130px;
            font-size: 12px;
            color: rgba(255,255,255,0.85);
        }
        .lp-row input[type="range"] {
            flex: 1;
        }
        .lp-value {
            min-width: 52px;
            text-align: right;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            color: rgba(255,255,255,0.85);
        }
        #lpPreviewCanvas {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
            display: block;
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.12);
        }
        .lp-note {
            margin-top: 8px;
            font-size: 11px;
            line-height: 1.35;
            color: rgba(255,255,255,0.7);
        }

        /* --- Global controls wrapper --- */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: none;
            text-align: center;
            user-select: none;
            flex-direction: column;
            align-items: center;
        }
        .control-button {
            padding: 6px 12px;
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 12px;
            margin-right: 8px;
        }
        .control-button:hover { background: rgba(0,0,0,0.7); }
        .control-button.active { background: #4285f4; }
        .control-row {
            display: flex;
            justify-content: center;
            margin-bottom: 12px;
        }

        /* --- Modern video controls --- */
        #videoControls {
            display: none;
            flex-direction: row;
            align-items: center;
            gap: 12px;
            background: rgba(0,0,0,0.6);
            padding: 10px 14px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.35);
            margin-bottom: 16px;
        }
        #playPauseButton {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            border: none;
            background: #4285f4;
            color: #fff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
        }
        #playPauseButton:hover { background: #3367d6; }

        /* Slider styling */
        #videoSlider {
            -webkit-appearance: none;
            appearance: none;
            width: 320px;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }
        #videoSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4285f4;
            cursor: pointer;
            border: none;
        }
        #videoSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4285f4;
            cursor: pointer;
            border: none;
        }

        /* --- Loading indicator & zoom info --- */
        #loadingIndicator {
            position: absolute;
            inset: 0;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(3px);
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0,0,0,0.15);
            border-left-color: #4285f4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 12px;
        }
        @keyframes spin { 0% {transform: rotate(0);} 100% {transform: rotate(360deg);} }

        #zoomInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.55);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 20;
            display: none;
        }

        /* --- View mode buttons (vertical) --- */
        #viewModeButtons {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 20;
            display: none;
            flex-direction: column;
            gap: 8px;
            user-select: none;
        }
        .view-mode-button {
            padding: 8px 14px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            min-width: 180px;
            text-align: center;
            white-space: nowrap;
            cursor: pointer;
        }
        .view-mode-button:hover { background: rgba(0,0,0,0.8); }
        .view-mode-button.active { background: rgba(66,133,244,0.85); }

        /* --- Upload Button --- */
        #resetButton {
            padding: 8px 16px;
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            z-index: 25;
            display: none;
            margin-top: 10px;
            height: 36px;
        }
        #resetButton:hover { background: rgba(0,0,0,0.7); }

        /* --- Screenshot Button --- */
        #screenshotButton {
            padding: 0;
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            z-index: 25;
            display: none;
            margin-left: 8px;
            margin-top: 10px;
            height: 36px;
            width: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        #screenshotButton:hover { background: rgba(0,0,0,0.7); }

        /* --- Bottom buttons container --- */
        #bottomButtonsContainer {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Screenshot flash effect --- */
        #screenshotFlash {
            position: absolute;
            inset: 0;
            background: white;
            opacity: 0;
            z-index: 40;
            pointer-events: none;
        }

        /* --- Screenshot feedback --- */
        #screenshotFeedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 45;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        /* --- Media drop overlay --- */
        #globalDropOverlay {
            position: absolute;
            inset: 0;
            background: rgba(18, 85, 204, 0.7);
            border: 5px dashed #fff;
            z-index: 50;
            display: none;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            backdrop-filter: blur(2px);
        }
        #globalDropOverlay p {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px 30px;
            border-radius: 8px;
            text-align: center;
        }

        /* Material icons styles (kept for backward compatibility; offline mode uses plain text icons) */
        .material-symbols-outlined {
            font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
            font-size: 24px;
        }

        /* ------------- Mobile Device Override ------------- */
        @media (max-width: 900px) {
            /* lift control bar */
            #controls { bottom: 80px !important; }

            /* lift view mode buttons */
            #viewModeButtons { bottom: 80px !important; }

            /* pull A-Frame‚Äôs VR / fullscreen button up and over everything */
            .a-enter-vr-button {
                bottom: 80px !important;
                z-index: 1000 !important;
            }
        }

        /* ------------- Hide Image Highlighting ------------- */
        ::selection {
            background: transparent;
        }
        ::moz-selection {
            background: transparent;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="dropArea">
        <h2>Select or Drag & Drop a 360¬∞ Media</h2>
        <p>Supported formats: All images, MP4, WebM</p>
        <input type="file" id="fileInput" accept="image/*, video/mp4, video/webm" />
        <button id="selectButton">Select Media</button>
    </div>

    <div id="aframeContainer"></div>
    <div id="threeContainer"></div>

    <div id="controls">
        <div id="videoControls">
            <button id="playPauseButton" aria-label="Play/Pause">‚è∏</button>
            <input type="range" id="videoSlider" min="0" max="100" value="0" step="0.1" />
        </div>
        <div id="bottomButtonsContainer">
            <button id="resetButton" class="control-button">Upload</button>
            <button id="screenshotButton" class="control-button" title="Take screenshot" aria-label="Screenshot">üì∑</button>
        </div>
    </div>

    <div id="viewModeButtons" aria-label="View mode buttons">
        <button id="modeMonoButton" class="view-mode-button active" title="Monoscopic panorama">Mono / ÂçïÁúº</button>
        <button id="modeTbButton" class="view-mode-button" title="Top/Bottom stereo panorama">Top/Bottom / ‰∏ä‰∏ã</button>
        <button id="modeLrButton" class="view-mode-button" title="Left/Right stereo panorama">Left/Right / Â∑¶Âè≥</button>
        <button id="modeLittlePlanetButton" class="view-mode-button" title="Little Planet mode (image)">Little Planet / Â∞èË°åÊòü</button>
    </div>

    <!-- Little Planet panel (three.js sphere mode) -->
    <div id="littlePlanetPanel" aria-label="Little Planet controls">
        <h3>Little Planet / Â∞èË°åÊòüÔºàÁêÉ‰ΩìË¥¥ÂõæÊ†°ÂáÜÔºâ</h3>
        <div class="lp-row">
            <label for="lpHorizon">Âú∞Âπ≥Á∫øÂúÜÂçäÂæÑÔºàËµ§ÈÅìÔºâ</label>
            <input id="lpHorizon" type="range" min="10" max="98" step="1" value="50" />
            <div class="lp-value" id="lpHorizonVal">50%</div>
        </div>
        <div class="lp-row">
            <label for="lpInvert">ÂèçËΩ¨ÔºàÂ§©Âú∞‰∫íÊç¢Ôºâ</label>
            <input id="lpInvert" type="checkbox" />
            <div class="lp-value"></div>
        </div>
        <canvas id="lpPreviewCanvas" width="512" height="512"></canvas>
        <div class="lp-note">ÊãñÂä®ÊªëÂùóËÆ©ËôöÁ∫øÂúÜ‰ªé‰∏≠ÂøÉÂêëÂ§ñÊâ©Â§ßÔºåÁõ¥Âà∞<b>ÂàöÂ•ΩË¥¥‰ΩèÂú∞Âπ≥Á∫øÔºàËµ§ÈÅìÔºâ</b>ÈÇ£‰∏ÄÂúà„ÄÇ</div>
    </div>

    <div id="loadingIndicator">
        <div class="spinner"></div>
        <p>Loading media‚Ä¶</p>
    </div>

    <div id="zoomInfo">Zoom: 80¬∞</div>

    <!-- Screenshot flash animation -->
    <div id="screenshotFlash"></div>

    <!-- Screenshot feedback -->
    <div id="screenshotFeedback">Screenshot saved!</div>

    <!-- Global drop overlay -->
    <div id="globalDropOverlay">
        <p>Drop 360¬∞ media to replace current view</p>
    </div>
</div>

<script>
    // Extract media URL from query parameters if present
    function getMediaUrlFromParams() {
        const urlParams = new URLSearchParams(window.location.search);
        const mediaUrl = urlParams.get('url') || urlParams.get('src');
        const stereoParam = urlParams.get('stereo');

        let stereoMode = 0; // Default: mono

        if (stereoParam) {
            const stereoLower = stereoParam.toLowerCase();
            switch (stereoLower) {
                case 'tb':
                case 'vertical':
                case '1':
                stereoMode = 1;
                break;
                case 'lr':
                case 'horizontal':
                case '2':
                stereoMode = 2;
                break;
                default:
                    stereoMode = 0; // mono
            }
        }

        return {
            url: mediaUrl,
            stereoMode: stereoMode
        };
    }

    // --- Little Planet shader (images only) ---
    // Inverse stereographic projection from plane -> sphere, sampling equirectangular texture
    // Inspired by common "tiny planet" mapping: lat = PI/2 - 2*atan(r), lon = atan(y,x)
    if (window.AFRAME && (!AFRAME.shaders || !AFRAME.shaders['little-planet'])) {
        AFRAME.registerShader('little-planet', {
            schema: {
                src: { type: 'map', is: 'uniform' },
                yawOffset: { type: 'number', is: 'uniform', default: -1.57079632679 } // -90deg to match panorama rotation
            },
            vertexShader: `
                varying vec2 vUV;
                void main() {
                    vUV = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D src;
                uniform float yawOffset;
                varying vec2 vUV;

                const float PI = 3.1415926535897932384626433832795;

                void main() {
                    // Map UV to plane coords in [-1, 1]
                    vec2 p = vUV * 2.0 - 1.0;
                    float r = length(p);

                    // Optional circular crop (black outside)
                    if (r > 1.0) {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        return;
                    }

                    float lon = atan(p.y, p.x) + yawOffset;
                    float lat = (PI * 0.5) - 2.0 * atan(r);

                    float u = lon / (2.0 * PI) + 0.5;
                    float v = lat / PI + 0.5;

                    // Wrap horizontally
                    u = fract(u);
                    v = clamp(v, 0.0, 1.0);

                    gl_FragColor = texture2D(src, vec2(u, v));
                }
            `
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        /* ------------------ DOM references ------------------ */
        const elements = {
            dropArea: document.getElementById('dropArea'),
            fileInput: document.getElementById('fileInput'),
            selectButton: document.getElementById('selectButton'),
            aframeContainer: document.getElementById('aframeContainer'),
            threeContainer: document.getElementById('threeContainer'),
            controls: document.getElementById('controls'),
            resetButton: document.getElementById('resetButton'),
            viewModeButtons: document.getElementById('viewModeButtons'),
            modeMonoButton: document.getElementById('modeMonoButton'),
            modeTbButton: document.getElementById('modeTbButton'),
            modeLrButton: document.getElementById('modeLrButton'),
            modeLittlePlanetButton: document.getElementById('modeLittlePlanetButton'),
            littlePlanetPanel: document.getElementById('littlePlanetPanel'),
            lpHorizon: document.getElementById('lpHorizon'),
            lpHorizonVal: document.getElementById('lpHorizonVal'),
            lpInvert: document.getElementById('lpInvert'),
            lpPreviewCanvas: document.getElementById('lpPreviewCanvas'),
            videoControls: document.getElementById('videoControls'),
            playPauseButton: document.getElementById('playPauseButton'),
            videoSlider: document.getElementById('videoSlider'),
            loadingIndicator: document.getElementById('loadingIndicator'),
            zoomInfo: document.getElementById('zoomInfo'),
            screenshotButton: document.getElementById('screenshotButton'),
            screenshotFlash: document.getElementById('screenshotFlash'),
            screenshotFeedback: document.getElementById('screenshotFeedback'),
            globalDropOverlay: document.getElementById('globalDropOverlay'),
            container: document.getElementById('container')
        };

        /* ------------------ App state ------------------ */
        const state = {
            scene: null,
            videoElement: null,
            isPlaying: true,
            currentFov: 80,
            currentMedia: null,
            isMediaImage: false,
            stereoMode: 0,
            // 0: Mono panorama, 1: Top/Bottom panorama, 2: Left/Right panorama, 3: Little Planet (mono)
            displayModeIndex: 0,
            three: {
                renderer: null,
                scene: null,
                camera: null,
                sphere: null,
                uniforms: null,
                texture: null,
                texImage: null,
                texAspect: 1,
                horizonPct: 50,
                invert: false,
                camYaw: 0,
                camPitch: 0,
                isDragging: false,
                lastX: 0,
                lastY: 0,
                renderPending: false,
                onResize: null
            },
            isDraggingFile: false
        };

        /* ------------------ Helpers ------------------ */
        const helpers = {
            showLoading: (flag) => {
                elements.loadingIndicator.style.display = flag ? 'flex' : 'none';
            },

            updateFov: (delta) => {
                state.currentFov = Math.min(179, Math.max(1, state.currentFov + delta));
                const cam = document.querySelector('#mainCamera');
                if (cam) cam.setAttribute('camera', 'fov', state.currentFov);
                elements.zoomInfo.textContent = `Zoom: ${Math.round(state.currentFov)}¬∞`;
                elements.zoomInfo.style.background = 'rgba(66,133,244,0.7)';
                setTimeout(() => elements.zoomInfo.style.background = 'rgba(0,0,0,0.55)', 300);
                // Little Planet uses a full-screen plane: keep it fitted when FOV changes
                helpers.updateLittlePlanetScale();
            },

            updatePlayPauseIcon: () => {
                elements.playPauseButton.textContent = state.isPlaying ? '‚è∏' : '‚ñ∂';
            },

            preventDefaults: (e) => {
                e.preventDefault();
                e.stopPropagation();
            },

            setDisplayModeIndex: (idx) => {
                state.displayModeIndex = ((idx % 4) + 4) % 4;
                // Keep stereoMode in sync (Little Planet is always mono for now)
                state.stereoMode = state.displayModeIndex === 3 ? 0 : state.displayModeIndex;
                helpers.updateViewModeButtons();
            },

            updateViewModeButtons: () => {
                const btns = [
                    elements.modeMonoButton,
                    elements.modeTbButton,
                    elements.modeLrButton,
                    elements.modeLittlePlanetButton
                ];
                btns.forEach((btn, i) => {
                    if (!btn) return;
                    if (i === state.displayModeIndex) btn.classList.add('active');
                    else btn.classList.remove('active');
                });
            },

            showLittlePlanetUI: (show) => {
                elements.threeContainer.style.display = show ? 'block' : 'none';
                elements.littlePlanetPanel.style.display = show ? 'block' : 'none';
            },

            updateLittlePlanetPanelValues: () => {
                elements.lpHorizon.value = String(state.three.horizonPct);
                elements.lpHorizonVal.textContent = `${Math.round(state.three.horizonPct)}%`;
                elements.lpInvert.checked = !!state.three.invert;
            },

            drawLittlePlanetPreview: () => {
                const canvas = elements.lpPreviewCanvas;
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                const w = canvas.width;
                const h = canvas.height;
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.fillRect(0, 0, w, h);

                const img = state.three.texImage;
                if (img) {
                    const iw = img.width || img.naturalWidth || 0;
                    const ih = img.height || img.naturalHeight || 0;
                    const s = Math.min(w / Math.max(1, iw), h / Math.max(1, ih));
                    const dw = iw * s;
                    const dh = ih * s;
                    const dx = (w - dw) / 2;
                    const dy = (h - dh) / 2;
                    ctx.drawImage(img, dx, dy, dw, dh);

                    const minDim = Math.min(dw, dh);
                    const cx = dx + dw / 2;
                    const cy = dy + dh / 2;
                    const rr = (minDim / 2) * (state.three.horizonPct / 100.0);

                    ctx.beginPath();
                    ctx.arc(cx, cy, rr, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 235, 59, 0.95)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.setLineDash([6, 6]);
                    ctx.strokeStyle = 'rgba(0,0,0,0.7)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.setLineDash([]);
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.75)';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Êú™Âä†ËΩΩÂõæÁâá', w / 2, h / 2);
                }
            },

            threeRenderOnce: () => {
                const t = state.three;
                if (!t.renderer || !t.scene || !t.camera) return;
                if (t.renderPending) return;
                t.renderPending = true;
                requestAnimationFrame(() => {
                    t.renderer.render(t.scene, t.camera);
                    t.renderPending = false;
                });
            },

            disposeThree: () => {
                const t = state.three;

                if (t.onResize) {
                    window.removeEventListener('resize', t.onResize);
                    t.onResize = null;
                }

                if (t.texture) {
                    try { t.texture.dispose(); } catch (_) {}
                    t.texture = null;
                }

                if (t.sphere) {
                    try {
                        if (t.sphere.geometry) t.sphere.geometry.dispose();
                        if (t.sphere.material) t.sphere.material.dispose();
                    } catch (_) {}
                    t.sphere = null;
                }

                if (t.renderer) {
                    try { t.renderer.dispose(); } catch (_) {}
                    if (t.renderer.domElement && t.renderer.domElement.parentElement) {
                        t.renderer.domElement.parentElement.removeChild(t.renderer.domElement);
                    }
                    t.renderer = null;
                }

                t.scene = null;
                t.camera = null;
                t.uniforms = null;
                t.texImage = null;
                t.texAspect = 1;
                t.camYaw = 0;
                t.camPitch = 0;
                t.isDragging = false;
                t.renderPending = false;

                helpers.showLittlePlanetUI(false);
            },

            updateLittlePlanetScale: () => {
                if (state.displayModeIndex !== 3) return;
                const plane = document.querySelector('#littlePlanetPlane');
                if (!plane) return;

                const z = 1; // distance from camera (plane will be at z = -1)
                const fovRad = (state.currentFov * Math.PI) / 180;
                const halfH = Math.tan(fovRad / 2) * z;
                const aspect = window.innerWidth / Math.max(1, window.innerHeight);
                const height = halfH * 2;
                const width = height * aspect;

                // A-Frame a-plane supports width/height attributes
                plane.setAttribute('width', width);
                plane.setAttribute('height', height);
            },

            updateSlider: () => {
                if (!state.videoElement || !state.videoElement.duration) return;
                const val = (state.videoElement.currentTime / state.videoElement.duration) * 100;
                elements.videoSlider.value = val;
            },

            dist: (t) => {
                return Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
            },

            showGlobalDropOverlay: (show) => {
                elements.globalDropOverlay.style.display = show ? 'flex' : 'none';
            }
        };

        /* ------------------ Media handling ------------------ */
        const mediaHandlers = {
            processFile: (file) => {
                helpers.showLoading(true);
                state.currentFov = 80;
                elements.zoomInfo.textContent = 'Zoom: 80¬∞';
                elements.videoControls.style.display = 'none';
                elements.viewModeButtons.style.display = 'none';
                helpers.setDisplayModeIndex(0);

                const reader = new FileReader();
                reader.onload = (e) => {
                    const url = e.target.result;
                    state.currentMedia = url;
                    state.isMediaImage = file.type.startsWith('image/');
                    state.isMediaImage ? mediaHandlers.createImageView(url) : mediaHandlers.createVideoPanorama(url);
                };
                reader.readAsDataURL(file);
            },

            processStereoImage: (src, callback) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    if (state.stereoMode === 1) { // Vertical (top/bottom)
                        canvas.width = img.width;
                        canvas.height = img.height / 2;
                        ctx.drawImage(img, 0, 0, img.width, img.height / 2, 0, 0, canvas.width, canvas.height);
                    } else if (state.stereoMode === 2) { // Horizontal (left/right)
                        canvas.width = img.width / 2;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0, img.width / 2, img.height, 0, 0, canvas.width, canvas.height);
                    } else {
                        // Non-stereo, use full image
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                    }

                    callback(canvas.toDataURL('image/jpeg', 0.95));
                };
                img.onerror = () => {
                    helpers.showLoading(false);
                    alert('Error loading image.');
                };
                img.src = src;
            },

            createImagePanorama: (src) => {
                helpers.showLoading(true);

                mediaHandlers.processStereoImage(src, (processedSrc) => {
                    interfaceHandlers.cleanupScene();

                    state.scene = document.createElement('a-scene');
                    state.scene.setAttribute('embedded','');
                    state.scene.setAttribute('xr-mode-ui','enabled: true');

                    const sky = document.createElement('a-sky');
                    sky.setAttribute('src', processedSrc);
                    sky.setAttribute('material', 'npot: true');
                    sky.setAttribute('rotation', '0 -90 0');
                    sky.setAttribute('geometry', 'segmentsHeight: 64; segmentsWidth: 128');

                    const camera = document.createElement('a-entity');
                    camera.setAttribute('camera', `fov: ${state.currentFov}`);
                    camera.setAttribute('look-controls', 'reverseMouseDrag: true');
                    camera.setAttribute('wasd-controls', 'enabled: false');
                    camera.setAttribute('position', '0 1.6 0');
                    camera.setAttribute('id', 'mainCamera');

                    state.scene.appendChild(sky);
                    state.scene.appendChild(camera);
                    elements.aframeContainer.appendChild(state.scene);

                    sky.addEventListener('loaded', () => helpers.showLoading(false));
                    sky.addEventListener('error', () => {
                        helpers.showLoading(false);
                        alert('Error loading panorama image.');
                    });

                    elements.dropArea.classList.add('hidden');
                    elements.controls.style.display = 'flex';
                    elements.zoomInfo.style.display = 'block';
                    elements.viewModeButtons.style.display = 'flex';
                    helpers.updateViewModeButtons();
                    elements.resetButton.style.display = 'block';
                    elements.screenshotButton.style.display = 'block';
                });
            },

            createLittlePlanetThreeSphere: (src) => {
                helpers.showLoading(true);

                // Always mono for this view (crop if the original is stereo)
                const savedStereo = state.stereoMode;
                state.stereoMode = 0;

                mediaHandlers.processStereoImage(src, (processedSrc) => {
                    state.stereoMode = savedStereo;

                    // Clean up A-Frame and any previous three instance
                    interfaceHandlers.cleanupScene();
                    helpers.disposeThree();

                    if (!window.THREE) {
                        helpers.showLoading(false);
                        alert('three.js not loaded.');
                        return;
                    }

                    const t = state.three;
                    helpers.showLittlePlanetUI(true);
                    helpers.updateLittlePlanetPanelValues();

                    t.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                    t.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
                    elements.threeContainer.appendChild(t.renderer.domElement);

                    t.scene = new THREE.Scene();
                    t.camera = new THREE.PerspectiveCamera(75, 1, 0.01, 50);
                    t.camera.position.set(0, 0, 0);
                    t.camera.rotation.order = 'YXZ';
                    t.camYaw = 0;
                    t.camPitch = 0;

                    t.uniforms = {
                        uTex: { value: null },
                        uHorizon: { value: t.horizonPct / 100.0 },
                        uTexAspect: { value: 1.0 },
                        uInvert: { value: t.invert ? 1.0 : 0.0 }
                    };

                    const sphereMaterial = new THREE.ShaderMaterial({
                        uniforms: t.uniforms,
                        side: THREE.BackSide,
                        vertexShader: `
                            varying vec3 vDir;
                            void main() {
                                vDir = normalize(position);
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            precision highp float;
                            uniform sampler2D uTex;
                            uniform float uHorizon;
                            uniform float uTexAspect;
                            uniform float uInvert;
                            varying vec3 vDir;
                            const float PI = 3.1415926535897932384626433832795;
                            void main() {
                                vec3 d = normalize(vDir);
                                float lon = atan(d.x, d.z);
                                float lat = asin(clamp(d.y, -1.0, 1.0));

                                // Invert swaps hemispheres (sky/ground) while keeping equator fixed
                                if (uInvert > 0.5) lat = -lat;

                                // Square mapping: edge=north pole, center=south pole, horizon circle=equator
                                float re = clamp(uHorizon, 0.01, 0.99);
                                float r;
                                if (lat >= 0.0) {
                                    r = re + (lat / (PI * 0.5)) * (1.0 - re);
                                } else {
                                    r = ((lat + PI * 0.5) / (PI * 0.5)) * re;
                                }
                                vec2 base = vec2(cos(lon), sin(lon)) * r;

                                // aspect-correct sampling for rectangular textures (inscribed square)
                                float sx = 1.0;
                                float sy = 1.0;
                                if (uTexAspect > 1.0) {
                                    sx = 1.0 / uTexAspect;
                                } else {
                                    sy = uTexAspect;
                                }
                                vec2 uv = vec2(0.5 + base.x * 0.5 * sx, 0.5 + base.y * 0.5 * sy);
                                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                                    return;
                                }
                                vec3 col = texture2D(uTex, uv).rgb;
                                gl_FragColor = vec4(col, 1.0);
                            }
                        `
                    });

                    t.sphere = new THREE.Mesh(new THREE.SphereGeometry(10, 96, 64), sphereMaterial);
                    t.scene.add(t.sphere);

                    const clampPitch = () => {
                        t.camPitch = Math.max(-Math.PI * 0.49, Math.min(Math.PI * 0.49, t.camPitch));
                    };
                    const applyCamRot = () => {
                        clampPitch();
                        t.camera.rotation.set(t.camPitch, t.camYaw, 0);
                    };
                    applyCamRot();

                    // Pointer look-around
                    const onPointerDown = (e) => {
                        t.isDragging = true;
                        t.lastX = e.clientX;
                        t.lastY = e.clientY;
                        t.renderer.domElement.setPointerCapture && t.renderer.domElement.setPointerCapture(e.pointerId);
                    };
                    const onPointerMove = (e) => {
                        if (!t.isDragging) return;
                        const dx = e.clientX - t.lastX;
                        const dy = e.clientY - t.lastY;
                        t.lastX = e.clientX;
                        t.lastY = e.clientY;
                        t.camYaw -= dx * 0.003;
                        t.camPitch -= dy * 0.003;
                        applyCamRot();
                        helpers.threeRenderOnce();
                    };
                    const onPointerUp = () => { t.isDragging = false; };
                    t.renderer.domElement.addEventListener('pointerdown', onPointerDown);
                    t.renderer.domElement.addEventListener('pointermove', onPointerMove);
                    t.renderer.domElement.addEventListener('pointerup', onPointerUp);
                    t.renderer.domElement.addEventListener('pointercancel', onPointerUp);
                    t.renderer.domElement.addEventListener('pointerleave', onPointerUp);

                    // Resize
                    const resize = () => {
                        const w = elements.threeContainer.clientWidth;
                        const h = elements.threeContainer.clientHeight;
                        t.renderer.setSize(w, h, false);
                        t.camera.aspect = w / Math.max(1, h);
                        t.camera.updateProjectionMatrix();
                        helpers.threeRenderOnce();
                    };
                    t.onResize = resize;
                    window.addEventListener('resize', resize);
                    resize();

                    // Load texture (data URL)
                    const loader = new THREE.TextureLoader();
                    loader.load(
                        processedSrc,
                        (tex) => {
                            tex.colorSpace = THREE.SRGBColorSpace;
                            tex.minFilter = THREE.LinearMipmapLinearFilter;
                            tex.magFilter = THREE.LinearFilter;
                            tex.wrapS = THREE.RepeatWrapping;
                            tex.wrapT = THREE.ClampToEdgeWrapping;
                            tex.anisotropy = Math.min(8, t.renderer.capabilities.getMaxAnisotropy());
                            t.texture = tex;
                            t.uniforms.uTex.value = tex;
                            const iw = tex.image && tex.image.width ? tex.image.width : 0;
                            const ih = tex.image && tex.image.height ? tex.image.height : 0;
                            if (iw && ih) {
                                t.texAspect = iw / ih;
                                t.uniforms.uTexAspect.value = t.texAspect;
                                t.texImage = tex.image;
                            } else {
                                t.texAspect = 1;
                                t.uniforms.uTexAspect.value = 1;
                                t.texImage = null;
                            }
                            helpers.drawLittlePlanetPreview();
                            helpers.showLoading(false);
                            helpers.threeRenderOnce();
                        },
                        undefined,
                        () => {
                            helpers.showLoading(false);
                            alert('Error loading Little Planet texture.');
                        }
                    );

                    // UI state
                    elements.dropArea.classList.add('hidden');
                    elements.controls.style.display = 'flex';
                    elements.zoomInfo.style.display = 'none';
                    elements.viewModeButtons.style.display = 'flex';
                    helpers.updateViewModeButtons();
                    elements.resetButton.style.display = 'block';
                    elements.screenshotButton.style.display = 'block';
                });
            },

            createImageView: (src) => {
                // 0..2 => panorama; 3 => little planet
                if (state.displayModeIndex === 3) {
                    mediaHandlers.createLittlePlanetThreeSphere(src);
                } else {
                    mediaHandlers.createImagePanorama(src);
                }
            },

            createVideoPanorama: (src) => {
                interfaceHandlers.cleanupScene();

                state.scene = document.createElement('a-scene');
                state.scene.setAttribute('embedded','');
                state.scene.setAttribute('xr-mode-ui','enabled: true');

                // Assets
                const assets = document.createElement('a-assets');
                state.scene.appendChild(assets);

                state.videoElement = document.createElement('video');
                state.videoElement.setAttribute('id', 'videoAsset');
                state.videoElement.setAttribute('src', src);
                state.videoElement.setAttribute('crossorigin', 'anonymous');
                state.videoElement.setAttribute('playsinline', '');
                state.videoElement.setAttribute('webkit-playsinline', '');
                state.videoElement.setAttribute('preload', 'metadata');
                state.videoElement.setAttribute('loop', '');
                assets.appendChild(state.videoElement);

                // Videosphere
                const vidsphere = document.createElement('a-videosphere');
                vidsphere.setAttribute('src', '#videoAsset');
                vidsphere.setAttribute('rotation', '0 -90 0');
                state.scene.appendChild(vidsphere);

                // Camera
                const camera = document.createElement('a-entity');
                camera.setAttribute('camera', `fov: ${state.currentFov}`);
                camera.setAttribute('look-controls', 'reverseMouseDrag: true');
                camera.setAttribute('wasd-controls', 'enabled: false');
                camera.setAttribute('position', '0 1.6 0');
                camera.setAttribute('id', 'mainCamera');
                state.scene.appendChild(camera);

                elements.aframeContainer.appendChild(state.scene);

                // UI state
                elements.dropArea.classList.add('hidden');
                elements.controls.style.display = 'flex';
                elements.videoControls.style.display = 'flex';
                elements.zoomInfo.style.display = 'block';
                elements.viewModeButtons.style.display = 'none'; // Hide view mode buttons for videos
                elements.resetButton.style.display = 'block';
                elements.screenshotButton.style.display = 'block';
                state.isPlaying = true;
                helpers.updatePlayPauseIcon();

                // Event listeners
                state.videoElement.addEventListener('loadedmetadata', () => {
                    helpers.showLoading(false);
                    elements.videoSlider.value = 0;
                    state.videoElement.play().catch(() => {}); // autoplay may require user gesture
                });
                state.videoElement.addEventListener('timeupdate', helpers.updateSlider);
            },

            // Load media from URL if provided
            loadMediaFromUrl: (url, initialStereoMode = 0) => {
                helpers.showLoading(true);

                // Set initial display mode (Little Planet not exposed via URL params yet)
                helpers.setDisplayModeIndex(initialStereoMode);

                // Determine if it's a video based on extension
                const lowerUrl = url.toLowerCase();
                const isVideo = ['.mp4', '.webm'].some(ext => lowerUrl.endsWith(ext));

                if (isVideo) {
                    // Handle video (stereo mode not supported for videos in current implementation)
                    state.currentMedia = url;
                    state.isMediaImage = false;
                    helpers.setDisplayModeIndex(0); // Reset to default for videos
                    mediaHandlers.createVideoPanorama(url);
                } else {
                    // Handle image with stereo support
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        state.currentMedia = url;
                        state.isMediaImage = true;
                        mediaHandlers.createImageView(url);
                    };
                    img.onerror = () => {
                        helpers.showLoading(false);
                        alert('Unsupported media type or inaccessible URL');
                    };
                    img.src = url;
                }
            }
        };

        /* ------------------ Interface handlers ------------------ */
        const interfaceHandlers = {
            takeScreenshot: () => {
                const hasThree = state.displayModeIndex === 3 && state.three && state.three.renderer;
                if (!state.scene && !hasThree) return;

                // Temporarily hide UI elements
                const elementsToHide = [
                    elements.zoomInfo,
                    elements.controls,
                    elements.viewModeButtons,
                    elements.littlePlanetPanel
                ];

                // Store original display states
                const originalDisplays = elementsToHide.map(el => el.style.display);

                // Hide elements
                elementsToHide.forEach(el => el.style.display = 'none');

                // Let the render update (wait for next frame)
                requestAnimationFrame(() => {
                    // Take screenshot of canvas
                    let canvas = null;
                    if (hasThree) {
                        canvas = state.three.renderer.domElement;
                    } else {
                        canvas = elements.aframeContainer.querySelector('canvas');
                    }
                    if (!canvas) {
                        // Restore UI and return
                        elementsToHide.forEach((el, i) => el.style.display = originalDisplays[i]);
                        return;
                    }

                    // Create screenshot
                    const dataURL = canvas.toDataURL('image/png');

                    // Create download link
                    const downloadLink = document.createElement('a');
                    downloadLink.href = dataURL;
                    downloadLink.download = 'panorama-screenshot.png';

                    // Trigger download
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);

                    // Show flash effect
                    elements.screenshotFlash.style.opacity = '0.7';
                    setTimeout(() => {
                        elements.screenshotFlash.style.opacity = '0';
                    }, 100);

                    // Show feedback
                    elements.screenshotFeedback.style.opacity = '1';
                    setTimeout(() => {
                        elements.screenshotFeedback.style.opacity = '0';
                    }, 2000);

                    // Restore UI
                    setTimeout(() => {
                        elementsToHide.forEach((el, i) => el.style.display = originalDisplays[i]);
                    }, 300);
                });
            },

            cleanupScene: () => {
                helpers.disposeThree();
                if (state.scene) {
                    elements.aframeContainer.removeChild(state.scene);
                    state.scene = null;
                }
                if (state.videoElement) {
                    state.videoElement.pause();
                    state.videoElement = null;
                }
                elements.controls.style.display = 'none';
                elements.videoControls.style.display = 'none';
                elements.zoomInfo.style.display = 'none';
                elements.viewModeButtons.style.display = 'none';
                elements.resetButton.style.display = 'none';
                elements.screenshotButton.style.display = 'none';
                elements.dropArea.classList.remove('hidden');
                elements.fileInput.value = '';
                // NOTE: do not reset display mode here; this function is also used when switching modes.
                // Reset is handled by the "Upload" button click handler.
            }
        };

        /* ------------------ Event Listeners ------------------ */
        // File input and drop area
        elements.selectButton.addEventListener('click', () => elements.fileInput.click());
        elements.fileInput.addEventListener('change', (e) => {
            if (e.target.files.length) mediaHandlers.processFile(e.target.files[0]);
        });

        // Drag and drop events for initial drop area
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
            elements.dropArea.addEventListener(evt, helpers.preventDefaults);
        });

        ['dragenter', 'dragover'].forEach(evt => {
            elements.dropArea.addEventListener(evt, () => {
                elements.dropArea.style.borderColor = '#4285f4';
                elements.dropArea.style.background = '#e8f0fe';
            });
        });

        ['dragleave', 'drop'].forEach(evt => {
            elements.dropArea.addEventListener(evt, () => {
                elements.dropArea.style.borderColor = '#ccc';
                elements.dropArea.style.background = '#f5f5f5';
            });
        });

        elements.dropArea.addEventListener('drop', (e) => {
            const f = e.dataTransfer.files[0];
            if (!f) return;
            const valid = /^image\/|video\/(mp4|webm)/.test(f.type);
            valid ? mediaHandlers.processFile(f) : alert('Please upload an image or MP4/WebM video file.');
        });

        // Global drag and drop events
        document.addEventListener('dragenter', (e) => {
            helpers.preventDefaults(e);
            // Only show if there's already media loaded AND files are being dragged
            if (state.scene && !state.isDraggingFile && e.dataTransfer && e.dataTransfer.types.includes('Files')) {
                state.isDraggingFile = true;
                helpers.showGlobalDropOverlay(true);
            }
        });

        document.addEventListener('dragover', (e) => {
            helpers.preventDefaults(e);
            // Keep the overlay visible while dragging files
            if (state.isDraggingFile && e.dataTransfer && e.dataTransfer.types.includes('Files')) {
                helpers.showGlobalDropOverlay(true);
            }
        });

        document.addEventListener('dragleave', (e) => {
            helpers.preventDefaults(e);
            // Check if leaving the viewport
            if (e.clientX <= 0 || e.clientX >= window.innerWidth ||
                e.clientY <= 0 || e.clientY >= window.innerHeight) {
                state.isDraggingFile = false;
                helpers.showGlobalDropOverlay(false);
            }
        });

        document.addEventListener('drop', (e) => {
            helpers.preventDefaults(e);
            helpers.showGlobalDropOverlay(false);
            state.isDraggingFile = false;

            const f = e.dataTransfer.files[0];
            if (!f) return;

            const valid = /^image\/|video\/(mp4|webm)/.test(f.type);
            valid ? mediaHandlers.processFile(f) : alert('Please upload an image or MP4/WebM video file.');
        });

        // Video controls
        elements.videoSlider.addEventListener('input', () => {
            if (!state.videoElement || !state.videoElement.duration) return;
            const newTime = (elements.videoSlider.value / 100) * state.videoElement.duration;
            state.videoElement.currentTime = newTime;
            if (!state.isPlaying) {
                // ensure texture updates while paused
                state.videoElement.pause();
            }
        });

        elements.playPauseButton.addEventListener('click', () => {
            if (!state.videoElement) return;
            state.isPlaying ? state.videoElement.pause() : state.videoElement.play().catch(() => {});
            state.isPlaying = !state.isPlaying;
            helpers.updatePlayPauseIcon();
        });

        // Screenshot functionality
        elements.screenshotButton.addEventListener('click', interfaceHandlers.takeScreenshot);

        // Reset button
        elements.resetButton.addEventListener('click', () => {
            interfaceHandlers.cleanupScene();
            state.currentMedia = null;
            state.isMediaImage = false;
            helpers.setDisplayModeIndex(0);
        });

        // View mode buttons (images only)
        const applyImageMode = (modeIndex) => {
            if (!state.currentMedia || !state.isMediaImage) return;
            if (state.displayModeIndex === 3 && modeIndex !== 3) helpers.disposeThree();
            helpers.setDisplayModeIndex(modeIndex);
            mediaHandlers.createImageView(state.currentMedia);
        };
        elements.modeMonoButton.addEventListener('click', () => applyImageMode(0));
        elements.modeTbButton.addEventListener('click', () => applyImageMode(1));
        elements.modeLrButton.addEventListener('click', () => applyImageMode(2));
        elements.modeLittlePlanetButton.addEventListener('click', () => applyImageMode(3));

        // Little Planet (three.js) panel controls
        elements.lpHorizon.addEventListener('input', (e) => {
            state.three.horizonPct = parseFloat(e.target.value);
            helpers.updateLittlePlanetPanelValues();
            if (state.three.uniforms) state.three.uniforms.uHorizon.value = state.three.horizonPct / 100.0;
            helpers.drawLittlePlanetPreview();
            helpers.threeRenderOnce();
        });

        elements.lpInvert.addEventListener('change', () => {
            state.three.invert = !!elements.lpInvert.checked;
            helpers.updateLittlePlanetPanelValues();
            if (state.three.uniforms) state.three.uniforms.uInvert.value = state.three.invert ? 1.0 : 0.0;
            helpers.threeRenderOnce();
        });

        // Zoom handlers
        document.addEventListener('wheel', (e) => {
            if (!state.scene) return;
            helpers.updateFov(Math.sign(e.deltaY) * 2);
            e.preventDefault();
        }, { passive: false });

        // Pinch-to-zoom on laptop track pads and mobile devices
        let pinchStartDist = 0;
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) pinchStartDist = helpers.dist(e.touches);
        });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && state.scene) {
                const d = helpers.dist(e.touches);
                if (Math.abs(d - pinchStartDist) > 5) {
                    helpers.updateFov((pinchStartDist - d) > 0 ? 1 : -1);
                    pinchStartDist = d;
                }
                e.preventDefault();
            }
        }, { passive: false });

        // Remove default click & drag feature
        document.addEventListener('dragstart', (e) => {
            if (e.target.tagName === 'CANVAS' || e.target.closest('a-scene')) {
                e.preventDefault();
                return false;
            }
        });

        // Keep Little Planet plane fitted on resize
        window.addEventListener('resize', helpers.updateLittlePlanetScale);

        // Check for URL parameter and load media if present
        const mediaParams = getMediaUrlFromParams();
        if (mediaParams.url) {
            mediaHandlers.loadMediaFromUrl(mediaParams.url, mediaParams.stereoMode);
        }
    });
</script>
</body>
</html>
